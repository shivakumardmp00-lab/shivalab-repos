

===============================
Docker + Kubernetes + Jenkins
===============================

Pre-Requisites : Linux Basics + AWS Cloud Account

Course Content : 

Module-1 : Docker (Containerization)

			1) Life without Docker
			2) Life with Docker
			3) Docker Introduction
			4) Docker Architecture
			5) Docker Setup
			6) Dockerfile
			7) Docker Images
			8) Docker Containers
			9) Docker Registry
			10) Docker Compose
			11) Docker Volumes
			12) Docker Network
			13) Docker Swarm

Module-2 : Kubernetes (Orchestation)

			1) What is Orchestration
			2) Containerization vs Orchestration
			3) Kubernetes Introduction
			4) Kubernetes Architecture
			5) K8S Setup (AWS EKS)
			6) PODS & Services
			7) Namespaces
			8) RC & RS
			9) Deployment
			10) DeamonSet
			11) StatefulSet
			12) ConfigMap & Secrets
			13) Helm Charts
			14) IngressController
			15) K8S Monitoring (Grafana & Promethues)
			16) HPA
			17) Blue Green Deployment
			18) ELK Stack Setup

Module-3 : Jenkins (CI CD Server)

			1) What is Build & Deployment process
			2) Challenges with manual process
			3) Build & Deployment Automation (CICD)
			4) What is Jenkins
			5) Jenkins Setup in Linux VM
			6) User Management in Jenkins
			7) Plugins Management
			8) Secrets management
			9) Pipelines
			10) Declarative vs Scripted
			11) Master Slave Architecture
			12) Jenkins Backup

Module-4 : Docker + K8S + Jenkins Integration (CI CD Project)			

==================
Course Details
==================

Duration : 1 Month

Class Timings : 6:00 PM to 7:30 PM IST (Mon-Fri)

Daily softcopy notes will be provided

Backup videos will be shared for revision (1 year validity)

Course Fee : 8000 INR


=========================
Application Architecture
=========================

1) Frontend : User interface (UI)

2) Backend : Business Logic

3) Database : Storage

==========================
Tech stack of application
==========================

Frontend  : Angular 18v

Backend : JAVA 17v

Database : MySQL 8.5v

Webserver : Tomcat 9.0v


Note: If we want to run our application code, then we need to setup all required dependencies (softwares) in the machine.

Note: dependencies nothing but the softwares which are required to run our application.

	Ex: JAVA 17, Angular 18, MySQL 8.5, Tomcat 9.0....

Note: If we want to run same application in 100 machines then it is hectic task to setup dependencies.

=> We are going to face below challenges when we want to run application in multiple machines

			1) Dependencies setup is Time taking process

			2) Human Errors in setup

			3) Complex Rollback

=> To overcome above problems we can use Docker.

==================
What is Docker ?
==================

=> Docker is a free & open source software

=> Docker is used for containerization

Containerization = code + required softwares

=> Containerization means packaging application-code and application dependencies as single unit for execution.

=> With the help of docker we can run our application in any machine.

=> Docker will take care of dependencies installation required for application execution.

=> We can make our application portable using Docker.

====================
Docker Architecture
====================

1) Dockerfile

2) Docker Image

3) Docker Registry

4) Docker Container

=> Dockerfile is used to specify where is app code and what dependencies are required for our application execution.

Note: Using Dockerfile we can create Docker image.

=> Docker Image is a package which contains app-code + app-dependencies

=> Docker Registry is used to store docker images.

=> Docker container will be created when we run Docker image.

Note: Inside container our application will be executed.

==============
Docker Setup
=============

Git Repo For Steps : https://github.com/ashokitschool/DevOps-Documents/blob/main/02-Docker-Setup.md

==================
Docker Commands
==================

docker images : To display docker images available in our system.

docker pull <image-name> : To download docker image

docker run <image-name> : To create docker container

docker ps : To display running docker containers in our system.

docker ps -a : To display running + stopped containers

docker ps -q : To display running containers ids

docker logs <container-id> : To check container logs

docker stop <container-id> : To stop running container

docker start <container-id> : To start stopped container

docker stop $(docker ps -q) : stop all running containers

docker rm <container-id> : To delete container which is in stopped state

docker rmi <image-name> : To delete image

docker system prune -a : Remove stopped containers + un-used images


=======================================================
Running Real-world applications using docker images
=======================================================

### public docker image name (java springboot app) : ashokit/spring-boot-rest-api

docker pull ashokit/spring-boot-rest-api

docker run ashokit/spring-boot-rest-api

docker run -d ashokit/spring-boot-rest-api

Syntax : docker run -d -p <host-port>:<container-port> ashokit/spring-boot-rest-api

docker run -d -p 9090:9090 ashokit/spring-boot-rest-api

Note: Host port number we need to enable in ec2-vm security group inbound rules to allow the traffic.

Note: To access application running in the container we will use below URL

## Java App URL : http://host-public-ip:host-port/welcome/{name}


### public docker image name (python app) : ashokit/python-flask-app

docker pull ashokit/python-flask-app

docker run -d -p 5000:5000 ashokit/python-flask-app

## Python App URL : http://host-public-ip:host-port/

Note: Host port number we need to enable in ec2-vm security group inbound rules to allow the traffic.


========================
What is Port Mapping ?
========================

Note: By default, services running inside a Docker container are isolated and not accessible from outside.

=> Docker port mapping is the process of linking container port to host machine port.

=> It is used to allow external access to applications running inside the container.

Syntax : docker run -p <host_port>:<container_port> <image_name>

Note: host port and container port no need to be same.

=============
Dockerfile
=============

=> Dockerfile contains set of instructions to build docker image.

		Filename : Dockerfile

=> Inside dockerfile we will specify below things

		1) What Dependencies Required

		2) Where is project code

		3) Project execution process

=> To write dockerfile we will use below keywords

		1) FROM
		2) MAINTAINER
		3) RUN
		4) CMD
		5) COPY
		6) ADD
		7) WORKDIR
		8) EXPOSE
		9) ENTRYPOINT

=====
FROM
=====		

=> It is used to specify base image required to run our application.

Ex: 

FROM openjdk:17

FROM python:3.3

FROM tomcat:9.0

FROM mysql:8.5

FROM node:19.5

============
MAINTAINER
============

=> MAINTAINER is used to specify who is author of this Dockerfile.

=> This is Optional in Dockerfile.

Ex: MAINTAINER Ashok <79794445>

=====
RUN 
=====

=> RUN keyword is used to specify instructions (commands) to execute at the time of docker image creation.

Ex:

RUN 'git clone <repo-url>'

RUN 'mvn clean package'

Note: We can specify multiple RUN instructions in Dockerfile and all those will execute in sequential manner.

========
CMD
========

=> CMD keyword is used to specify instructions (commands) which are required to execute at the time of docker container creation.

Ex:

CMD 'java -jar app.jar'

CMD 'python app.py'

Note: If we write multiple CMD instructions in dockerfile, docker will execute only last CMD instruction.


===========
ENTRYPOINT
===========

=> It is used to execute instruction when container is getting created.

Note: ENTRYPOINT is used as alternate for 'CMD' instructions.


================================================
What is the diff between 'CMD' & 'ENTRYPOINT' ?
=================================================

=> CMD instructions we can override using cmd args while creating docker container.

=> ENTRYPOINT instructions we can't override.


=====
COPY
=====

=> COPY instruction is used to copy the files from source to destination.

Note: It is used to copy application code from host machine to container machine.

		Source : HOST Machine

		Destination : Container machine

Ex:

COPY /target/app.jar /usr/app/app.jar

COPY /target/webapp.war /usr/bin/tomcat/webapps/webapp.war

COPY app.py /usr/app/


=====
ADD
=====

=> ADD instruction is used to copy the files from source to destination.

Ex : 

ADD <source> <destination>

ADD <URL> <destination>

========
WORKDIR
========

=> WORKDIR instruction is used to set / change working directory in container machine.

Ex:

COPY target/app.jar /usr/app/

WORKDIR /usr/app/

========
EXPOSE
========

=> EXPOSE instruction is used to specify application is running on which PORT number.

Ex:

EXPOSE 8080

Note: By using EXPOSE keyword we can't change application port number. It is just to provide information the people who are reading our Dockerfile.

================================================
Dockerizing java web app (Without SpringBoot)
================================================

=> Java web app will be packaged as "war" file

Note: Using maven build tool we will package java applications.

=> war file will be created inside project "target" directory.

=> To deploy war file we need web server (Ex: tomcat).

=> Inside tomcat server "webapps" directory we will keep war file for application execution.

######### Dockerfile to run java web app ############

FROM tomcat:latest

EXPOSE 8080

COPY target/app.war /usr/local/tomcat/webapps/

==========
Lab Task
==========

@@ Java Web App Git Repo : https://github.com/ashokitschool/maven-web-app.git

Note: Connect with Docker VM using SSH client and execute below commands

# install git client
$ sudo yum install git -y

# install maven s/w
$ sudo yum install maven -y

# clone project git repo
$ git clone https://github.com/ashokitschool/maven-web-app.git

# build maven project
$ cd maven-web-app
$ mvn clean package

# check project war file
$ ls -l target

# build docker image
$ docker build -t <img-name> .
$ docker images

# Create Docker Container
$ docker run -d -p 8080:8080 <image-name>
$ docker ps

=> Enable host port number in security group inbound rules and access our application.

		URL :: http://public-ip:8080/maven-web-app/


=========================================
Dockerizing Java Spring Boot Application
=========================================		

=> Spring Boot is a framework which is used to simplify java application development process.

=> Every JAVA SpringBoot application will be packaged as "jar" file only.

Note: To package java application we will use 'Maven' as build tool.

=> To run spring boot application we need to execute jar file.

			### syntax: java -jar <jar-file-name>

Note: When we run springboot application jar file then springboot will start tomcat server with 8080 port number (embedded tomcat server).


######### Dockerfile to run SpringBoot App ############

FROM openjdk:17

COPY target/app.jar /usr/app/

WORKDIR /usr/app/

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]

==========
Lab Task
==========

## Java Spring Boot App Git Repo : https://github.com/ashokitschool/spring-boot-docker-app.git

Note: Connect with Docker VM using SSH client and execute below commands

# clone project git repo
$ git clone https://github.com/ashokitschool/spring-boot-docker-app.git

# build maven project
$ cd spring-boot-docker-app
$ mvn clean package

# check project war file
$ ls -l target

# build docker image
$ docker build -t <img-name> .
$ docker images

# Create Docker Container
$ docker run -d -p 9090:8080 <image-name>
$ docker ps

=> Enable host port number in security group inbound rules and access our application.

		URL :: http://public-ip:9090/


=================================
Dockerizing Python application 
=================================		

=> Python is a general purpose language.

Note: It is also called as scripting language.

=> We don't need any build tool for python applications.

=> We can run python application code directley like below

		Syntax : $ python app.py

=> If we need any libraries for python (Ex: Flask) application development then we will mention them in "requirements.txt" file.

Note: We will use "python pip" s/w to download libraries configured in requirements.txt file.


================== Python Flask App Dockerfile ==================

FROM python 3.6

COPY . /usr/app/

WORKDIR /usr/app/

RUN pip install -r requirements.txt

EXPOSE 5000

ENTRYPOINT ["python", "app.py"]

==========
Lab Task
==========

@@ Python Flask App Git Repo : https://github.com/ashokitschool/python-flask-docker-app.git


# Clone git repo
$ git clone https://github.com/ashokitschool/python-flask-docker-app.git

# Go inside project directory
$ cd python-flask-docker-app

# Create docker image
$ docker build -t ashokit/pyapp .
$ docker images

# Create container
$ docker run -d -p 5000:5000 ashokit/pyapp
$ docker ps

# Access application in browser
URL : 


==============================================================
Q) How to push Docker Image to Docker Hub / Docker Registry ?
==============================================================

$ docker images

$ docker tag <image-name> <docker-hub-username>/<img-name>:<tagname>

$ docker login

$ docker push <tagged-image-name>


===============
Docker Compose
===============

=> Earlier ppl developed projects using Monolithic Architecture (everthing in single app)

=> Now a days projects are developing based on Microservices architecture.

=> Microservices means multiple backend apis will be avialable

	Ex: 
			hotels-api
			flights-api
			trains-api
			cabs-api...

=> For every API we need to create seperate docker image and seperate docker container.

Note: When we have multiple containers then management will become very difficult (create containers / stop containers / start containers)

=> To overcome above problems we will use Docker Compose.

=> Docker Compose is used to manage Multi - Container Based applications.

=> In docker compose, using single command we can create / stop / start multiple containers at a time.


===================================
What is docker-compose.yml file ?
===================================

=> docker-compose.yml file is used to specify containers information.

=> The default file name is docker-compose.yml (we can change it).

=> docker-compose.yml file contains below 4 sections

---------------
version : 

services :

networks : 

volumes : 

---------------

version : It represents compose yml version

services : It represents containers information (image-name, port-mapping etc..)

networks : Represents docker network to run our containers

volumes : Represents containers storage location

======================
Docker Compose Setup
======================

# install docker compose

sudo curl -L "https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# Check docker compose is installed or not

$ docker-compose --version

================================================
Spring Boot with MySQL DB using Docker-Compose
================================================

# clone git repo
$ git clone https://github.com/ashokitschool/spring-boot-mysql-docker-compose.git

# go inside project directory
$ cd spring-boot-mysql-docker-compose

# build project using maven
$ mvn clean package -DskipTests=true

# build docker image
$ docker build -t spring-boot-mysql-app .

# check docker images
$ docker images

# create docker containers using docker-compose
$ docker-compose up -d

# check containers created
$ docker-compose ps

# delete containers
$ docker-compose down

